import os
import sys
sys.path.insert(0, os.path.abspath(os.path.join(os.path.dirname(__file__), '..')))
print("Current Working Directory:", os.getcwd())
import numpy as np
import pdb
from utils.cal_grid_density import grid_density
# import pandas as pd

# In this file we list several functions that calculate the final quality metrics based on the matrixs generated
# from the density tranformation part.


# 
def sum_of_averages_except_last_non_empty(lst):
    # Find the last non-empty index
    last_non_empty_index = None
    for i in range(len(lst) - 1, -1, -1):
        if lst[i]:  # Checks if the element is not empty
            last_non_empty_index = i
            break

    # Calculate the sum of averages except for the last non-empty index
    total_sum = 0
    for i in range(len(lst)):
        if lst[i] and i != last_non_empty_index:  # Check if not empty and not the last non-empty index
            total_sum += sum(lst[i]) / len(lst[i])  # Add the average of the current list
        total_sum = round(total_sum, 2)
    return total_sum


# 
def layers_matrix_calculation_same_class_average(lst):
    """This function is to transfer each element in matrix to an element
    that can be used to final matrix

    Args:
        lst (list): a list in color_matrix

    Returns:
        two arrays: two arrays that are related to to 
    """
    # Filter out empty lists
    non_empty_lists = [sublist for sublist in lst if sublist]
    
    total_sum = 0
    top_pixel = 0
    # Sum all elements except the last non-empty list
    for sublist in non_empty_lists[:-1]:
        total_sum += sum(sublist)
    # Handle the last non-empty list: sum all elements except the last one and add its average without the last element
    if non_empty_lists:  # Check if there's at least one non-empty list
        last_non_empty_list = non_empty_lists[-1]
        average_of_last_without_last = sum(last_non_empty_list[:-1]) / len(last_non_empty_list[:-1]) if len(last_non_empty_list[:-1]) > 0 else 0
        total_sum += average_of_last_without_last
        top_pixel = last_non_empty_list[-1]
    return total_sum, top_pixel


# We calculate the matrix for top layer matrix and the under layer matrix for single color of scatterplots
def sum_all_weight_pixel_noncolor(noncolor_matrix):
    """This function calculates the final matrix for quality metric
    by summing all the weighted values of pixels generated by the same classes with the top layer.

    Args:
        noncolor_matrix (numpy): the 2D array, where each element contains the weight values of data points covering specific pixels.

    Returns:
        two arrays: returns two arrays that are the top layer's matrix and the other layer's matrix.
    """
    pixel_height, pixel_width = noncolor_matrix.shape
    
    top_layer_matrix = np.zeros((pixel_height, pixel_width))
    other_layer_matrix = np.zeros((pixel_height, pixel_width))
    overall_layer_matrix = np.zeros((pixel_height, pixel_width))
    
    for px in range(pixel_width):
        for py in range(pixel_height):
            sum_value = 0
            non_zero_count = 0
            if len(noncolor_matrix[py, px]) != 0:
                top_layer_matrix[py, px] = noncolor_matrix[py, px][-1]
                for i in range(len(noncolor_matrix[py, px]) - 1):
                    if noncolor_matrix[py, px][i] != 0:
                        sum_value += noncolor_matrix[py, px][i]
                        non_zero_count += 1
            if non_zero_count != 0:
                other_layer_matrix[py, px] = sum_value
            else:
                other_layer_matrix[py, px] = 0  # or handle the case where there are no non-zero elements
            
            if sum_value == 0 or top_layer_matrix[py, px] == 0:
                overall_layer_matrix[py,px] = 0
            else:
                overall_layer_matrix[py,px] = sum_value/(sum_value + top_layer_matrix[py, px])
            # overall_layer_matrix[py,px] = sum_value/(sum_value + top_layer_matrix[py, px])
            
    return top_layer_matrix, other_layer_matrix, overall_layer_matrix


# We calculate the matrix for top layer matrix and the under layer matrix for multiple colors of scatteplots
def same_class_average_metric_color(color_matrix, weight_same_class, weight_diff_class):
    """This function is to calculate the final matrix for quality metric
    we sum all the weighted values of pixels generated by same or different classes with top layer

    Args:
        color_matrix (numpy): the 2D array, where each element contains the weight values of data points covering specific pixels

    Returns:
        two arrays: return two arrays that are top layer's matrix and other layer's matrix
    """
    
    pixel_height, pixel_width = color_matrix.shape

    def layers_matrix_calculation(lst):
        # Filter out empty lists
        non_empty_lists = [sublist for sublist in lst if sublist]
        
        if len(non_empty_lists) != 0:
        
            total_sum = 0
            top_pixel = 0
            n_different_class = 0
            n_same_class = 0
            i_diffrent_class = 0
            i_same_class = 0
            
            # category of the top pixel
            top_pixel_category = non_empty_lists[-1]['category']
            top_pixel = non_empty_lists[-1]['importance_value']
            if len(non_empty_lists) >1:
                # we extract the importance values in non_empty_lists that are not the last one and are not same category as the top pixel and sum them
                for sublist in non_empty_lists[:-1]:
                    if sublist['category'] != top_pixel_category:
                        n_different_class += sublist['importance_value'] * weight_diff_class
                        i_diffrent_class += 1
                # we extract the importance values in non_empty_lists that are not the last one and are the same category as the top pixel and sum them
                for sublist in non_empty_lists[:-1]:
                    if sublist['category'] == top_pixel_category:
                        n_same_class += sublist['importance_value'] * weight_same_class
                        i_same_class += 1
                        
                total_sum = (n_different_class/i_diffrent_class if i_diffrent_class != 0 else 0) + (n_same_class/i_same_class if i_same_class != 0 else 0)
                # total_sum = n_different_class + n_same_class
            else:
                total_sum = 0
                
            if total_sum == 0 and top_pixel == 0:
                overall_pixel = 0
            else:
                overall_pixel = 1 - top_pixel/(total_sum + top_pixel)

            return total_sum, top_pixel, overall_pixel, top_pixel_category
        else:
            return None, None, None, None
    
    top_layer_matrix = np.full((pixel_height, pixel_width), np.nan)
    top_layer_category_matrix = np.full((pixel_height, pixel_width), '', dtype=object)
    other_layer_matrix = np.full((pixel_height, pixel_width), np.nan)
    overall_layer_matrix = np.full((pixel_height, pixel_width), np.nan)
    for px in range(pixel_width):
        for py in range(pixel_height):
            # print(self.pixel_color_matrix[py, px])
            # finalize the pixel_matrix
            other_layer_matrix[py,px], top_layer_matrix[py,px], overall_layer_matrix[py,px], top_layer_category_matrix[py, px] = layers_matrix_calculation(color_matrix[py, px])
            # file.write(f'px: {px}, py: {py}, data: {pixel_matrix[py,px]}\n')
    
    # top_layer_density_matrix = grid_density(top_layer_category_matrix)
    
    # # We recalculate the top_layer_matrix based on the density matrix, by multiplying the density value with the top layer value
    # for i in range(pixel_height):
    #     for j in range(pixel_width):
    #         if top_layer_matrix[i, j] is not None:
    #             top_layer_matrix[i, j] = top_layer_matrix[i, j] * (9 - top_layer_density_matrix[i][j])**2
    

        
    return top_layer_matrix, other_layer_matrix, overall_layer_matrix



if __name__ == "__main__":

    array_loaded = np.load('internal_dataset/pixel_color_matrix.npy')

    # print(sum_all_weight_pixel(lst))